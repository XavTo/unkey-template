var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  checkAPIKey: () => checkAPIKey,
  extractLongToken: () => extractLongToken,
  extractLongTokenHash: () => extractLongTokenHash,
  extractShortToken: () => extractShortToken,
  generateAPIKey: () => generateAPIKey,
  getTokenComponents: () => getTokenComponents,
  hashLongToken: () => hashLongToken
});
module.exports = __toCommonJS(src_exports);
var import_node_crypto = require("crypto");
var import_node_util = require("util");
var import_bs58 = __toESM(require("bs58"));
var import_padStart = __toESM(require("lodash/padStart"));
var hashLongTokenToBuffer = (longToken) => (0, import_node_crypto.createHash)("sha256").update(longToken).digest();
var hashLongToken = (longToken) => hashLongTokenToBuffer(longToken).toString("hex");
var generateAPIKey = async ({
  keyPrefix,
  shortTokenPrefix = "",
  shortTokenLength = 8,
  longTokenLength = 24
} = {}) => {
  if (!keyPrefix)
    return {};
  const generatedRandomBytes = (0, import_node_util.promisify)(import_node_crypto.randomBytes);
  const [shortTokenBytes, longTokenBytes] = await Promise.all([
    generatedRandomBytes(shortTokenLength),
    generatedRandomBytes(longTokenLength)
  ]);
  let shortToken = (0, import_padStart.default)(import_bs58.default.encode(shortTokenBytes), shortTokenLength, "0").slice(0, shortTokenLength);
  const longToken = (0, import_padStart.default)(import_bs58.default.encode(longTokenBytes), longTokenLength, "0").slice(0, longTokenLength);
  const longTokenHash = hashLongToken(longToken);
  shortToken = (shortTokenPrefix + shortToken).slice(0, shortTokenLength);
  const token = `${keyPrefix}_${shortToken}_${longToken}`;
  return { shortToken, longToken, longTokenHash, token };
};
var extractLongToken = (token) => {
  var _a;
  return (_a = token.split("_").slice(-1)) == null ? void 0 : _a[0];
};
var extractShortToken = (token) => {
  var _a;
  return (_a = token.split("_")) == null ? void 0 : _a[1];
};
var extractLongTokenHash = (token) => hashLongToken(extractLongToken(token));
var getTokenComponents = (token) => ({
  longToken: extractLongToken(token),
  shortToken: extractShortToken(token),
  longTokenHash: hashLongToken(extractLongToken(token)),
  token
});
var checkAPIKey = (token, expectedLongTokenHash) => {
  const expectedLongTokenHashBuffer = Buffer.from(expectedLongTokenHash, "hex");
  const inputLongTokenHashBuffer = hashLongTokenToBuffer(extractLongToken(token));
  return (0, import_node_crypto.timingSafeEqual)(expectedLongTokenHashBuffer, inputLongTokenHashBuffer);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  checkAPIKey,
  extractLongToken,
  extractLongTokenHash,
  extractShortToken,
  generateAPIKey,
  getTokenComponents,
  hashLongToken
});
